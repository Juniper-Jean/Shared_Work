# Extra Annotations for Generate_Config_Files.py Script
2024 Feb 5

# `generate_config_files` Fn
##
for param_set_index in range(1, nr_param_sets + 1):
Iterates from 1 to `nr_param_sets` inclusive to align w/ param set numbering starting at 1.
`range()` fn generates nrs up to, but not including, `stop` val.
`range(1, nr_param_sets + 1)` generates nrs starting from 1 to `nr_param_sets`, inclusive of 1 & exclusive of `nr_param_sets + 1`.
`stop` arg is `nr_param_sets + 1`: `+ 1` ensures `range()` fn & loop inc last param set in sequence it generates.

`range(start, stop[, step])` fn generates sequence of nrs. Params:
- `start`- start val of sequence (inclusive)
- `stop`- end val (exclusive)
- `step` (optional)- if not provided, default val is 1.
Returns obj of custom class `range`- immutable sequence of nrs & iterable.

`start` arg is set to 1 because (Python indices typically start at 0, but, here) param set indexing starts at 1 to align w/ param set IDs numbered starting at 1.

`for param_set_index in range(...)` initiates `for` loop, iterating over sequence generated by `range()`.
`param_set_index` is the loop var that takes on ea val in the sequence, one at a time, for ea iteration of loop.


##
run_nr = ((param_set_index - 1) * nr_replicates) + replicate_index
We assign ea experimental run (job) a unique, sequential identifier (run nr).
Formula is designed to be universal & robust for calculating run nrs across any nr of param sets & any nr of replicates per param set (w/ assumption that count starts at 1 for both param sets & replicates).
Numbering starting at 1 aligns w/ `PBS_ARRAY_INDEX` env var provided by PBS job scheduler when running parallel jobs on HPC cluster.

Eg, 20 param sets & 5 replicates per set.
`param_set_index` ranges from 1 to 20 inclusive.
`replicate_index` ranges from 1 to 5 inclusive.
For param set 1, replicate 1: run_nr = ((1 - 1) * 5) + 1 = 1.
This way, 1st replicate of 1st param set gets run_nr = 1, aligning w/ `PBS_ARRAY_INDEX` 1.
param set 1, replicate 2: run_nr = ((1 - 1) * 5) + 2 = 2
param set 2, replicate 1: run_nr = ((2 - 1) * 5) + 1 = 6

This calculation ensures ea run nr is unique & sequential, starting at 1, & matches directly w/ `PBS_ARRAY_INDEX` for ea job.
Cmd `qsub -t 1-100 myscript.sh` in terminal on HPC server submits 100 jobs w/ `PBS_ARRAY_INDEX` values from 1 to 100.
PBS array indices align w/ run nrs & ea correspondes to a specific combination of param set & replicate.

`param_set_index`: current param set ID, starting at 1 up to total nr of param sets
`nr_replicates`: total nr of replicates per param set
`replicate_index`: current replicate index for given param set, starting from 1 up to nr_reps.


##
param_file_name = f'Parameters{param_set_index}.txt'
Use f-string to make str for param file name.
f-string allows for dynamic insertion of var into str (inclusion of `` var directly in str, forming dynamic str).

param_file_path = os.path.join(param_files_dir, param_file_name)
Construct path to param file.

run_output_dir = os.path.join(f'Param_Set{param_set_index}', f'Replicate{replicate_index}')
Construct path for / define run_output_dir.


# f-strings
In Python, strings come in 2 main forms: string literals & string variables.
string literal- sequence of chars directly written in code
'literal'- str is fixed/unchanging part of program- it's 'literally' what you see in source code.
string variable- str whose value can change & may not be directly visible in source code

f-string (formatted string literal)- special type of str literal- way to embed expressions, like vars, within str literal
When use f-string, you start w/ str literal that contains placeholders for dynamic content (where expressions, like vars, get embedded).
Despite containing dynamic content, f-strings remain literals; when evaluated, resulting str is fixed literal, not var.


# `os.path.join()` Fn
`os.path.join(path1, path2, ..., pathN)` fn concatenates path components into 1 path str. It automatically inserts correct path separator ('/') depending on OS.
`path1, path2, ..., pathN` params- strings representing path components to be joined together.
Returns single string representing combined file path, w/ appropriate separators inserted bw ea component.

Both these lines achieve same result- specifying path to save config file:
Using f-string: `config_file_name = f'{analysis_version}/Config_Files/config{run_nr}.json'`
`config_file_path = os.path.join(analysis_version, 'Config_Files', f'config_{run_nr}.json')`

Using `os.path.join()` to construct dir/file paths, as opposed to directly concatenating strings w/ f-strings, is generally best practice.
`os.path.join()` automatically uses correct path separator for OS on which script is run ('/' on Unix, '\' on Windows).
This makes code more portable across different OSs wo modification (provides reliable, system-agnostic method to handle file paths- cross-platform compatibility).
Hardcoding path separators can reduce portability bw OSs.

Similar to f-strings, `os.path.join()` easily handles both variables & literals, making it adaptable for constructing dynamically-generated paths.
Slight increase in verbosity is worthwhile tradeoff.


##
# Make dict to store details of ea run (ea replicate set of sims).
# Ea key represents specific detail about run & key val is assigned from corresponding var's val.
# Makes record to link parameter sets to outputs, streamlining data management.

config_data = {
    "param_set_ID": param_set_index,
    # Key "param_set_ID" stores a unique identifier for the parameter set used in this set of simulations.

    "param_file_name": param_file_name,
    "param_file_path": param_file_path,
    # relative path to the parameter file used in this set of simulations
    # Param file contains all settings & vals used to configure sims.
    # Storing filename allows for easy reference & traceability of sim settings.

    "replicate_nr": replicate_index, # replicate nr for sim set

    "run_output_dir": run_output_dir
    # directory structure `[version number of analysis]/Param_Set[ID]/Replicate[number]`, integral to both `../Data/` & `../Results/` directories. This is used, for each run, to locate & access output data of simulations & save analysis results.
}

config_file_name = f'config{run_nr}.json'
config_file_path = os.path.join(config_files_dir, config_file_name)
# Specify config file name, using f-string to embed run nr.
# Construct path to  config file.

with open(config_file_name, 'w') as config_file: # Open config file in write mode.
    json.dump(config_data, config_file, indent=4)
    # Write config data to file in JSON format.
    # `indent=4` arg formats JSON data in file for easy readability, using 4-space indent.

JSON file:
- text file w/ data formatted in JavaScript Object Notation (JSON).
- commonly used for config files due to its human-readable & machine-parseable format, making it ideal for data interchange b/w systems & storing config settings.

`json.dump(obj, file, indent=None)`- fn of `json` module
Params:
`obj`- Python object to be serialised (converted into a JSON formatted string).
`file`- file obj to which JSON data will be written.
`indent` (optional)- nr of spaces to use for printing JSON data (useful for readability).
`json.dump()` serialises `obj` as a JSON formatted stream to `file`.

`indent` param in `json.dump()` isn't strictly necessary, but it significantly improves readability of resulting JSON file.
Setting `indent=4` formats JSON output w/ ea lv in hierarchy indented by 4 spaces, making it easier for humans to read & understand structure of JSON data.
W/o indentation, JSON data would be saved in compact, 1-line format, which can be difficult to navigate, esp for big objs.


# `main` Fn
os.makedirs(config_files_dir, exist_ok=True)
Make dir if it doesn't exist.
Analysis version dir already exists- previous script in workflow made it.
`os.makedirs` fn in `os` module recursively creates a dir & any missing intermediate dirs in specified path.
`exist_ok=True` keyword arg tells `os.makedirs()` to do nothing if dir already exists, preventing any deletion/modification of existing data.
`os.makedirs(config_dir, exist_ok=True)` makes specified dir within analysis version dir & won't overwrite any existing data in analysis version dir (inc .txt parameter files).

`os.makedirs` fn in `os` module recursively creates a dir & any missing intermediate dirs in specified path.
General format: `os.makedirs(name, mode=0o777, exist_ok=False)`
Params:
`name` (str): path to dir to create. If intermediate dirs in path don't exist, they will be made as well.
`exist_ok` (bool, optional): If `False` (default), `FileExistsError` is raised if dir already exists.
If `True`, fn does nothing if dir already exists, preventing the error & making the operation idempotent.

`exist_ok=True` keyword arg tells `os.makedirs()` to do nothing if dir already exists, preventing any deletion/modification of existing data.

Method is safe & idempotent, meaning it can be run multiple times w/o causing errors or unintended side effects.
It safely makes dirs w/o affecting existing dirs/files.
Idempotency: Running script multiple times won't cause errors or unintended side effects if the dirs already exist, making script's dir creation steps idempotent.

(Setting `exist_ok=True` is useful when run script multiple times- where multiple instances may attempt to make the dir.)
